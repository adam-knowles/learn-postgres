A PostgreSQL session consists of three parts:

The postmaster
The client application
The server
Postmaster
The Postmaster is the supervisory daemon process that manages a PostgreSQL server. 
The postmaster daemon manages communication among the various server processes including 
initializing the server, shutting down the server, handling connection requests, 
and performing other background processes. In Azure Database for PostgreSQL, you don't 
have access to the file system, or to the Postmaster process.

Client applications
Clients run queries and interact with databases on an Azure Database for PostgreSQL server. 
To run queries, you need a client tool such as Azure Data Studio, DBeaver, pgAdmin, or psql. 
You'll learn about client tools in the next module.

Server processes
Cluster - a single PostgreSQL server can host multiple user databases. PostgreSQL refers to 
this collection of databases as a cluster. Each database is separate from the other, and users 
and applications interact with a single database. Users are created at the cluster or server level.

Data for these databases is stored in the cluster's data directory called PGDATA. 
The PGDATA data directory includes a file containing the version of PostgreSQL being run, 
pg_tblspc which contains links to tablespaces, and pg_xlog which contains the write ahead log files.

Note

Azure Databases for PostgreSQL is a service which manages storage and the underlying file system. As a user of this server you don't have direct access to the PGDATA directory, or any of its subdirectories.

In addition to the databases you create, there are three system databases:

postgres - the default database. After your server creates, you connect to the postgres database.
azure_maintenance - the database that manages service processes. You don't have direct access to this database.
azure_sys - the Query Store database. You must not modify the azure_sys database or its schemas. Changing anything in azure_sys prevents Query Store and other performance features from functioning correctly.
Schemas - A schema is a named grouping of database objects. Large databases with many objects benefit from organizing objects into schemas

Server parameters - PostgreSQL has several configuration files, which determine how the database engine should work. The main PostgreSQL configuration file is called postgresql.conf.

Azure Database for PostgreSQL replaced these configuration files with Server parameters, which can be accessed via the Azure portal, or using the Azure CLI.

Storage - Azure Database for PostgreSQL manages the data storage for you and is provisioned at the server level. Whether you select Burstable, General purpose, or Memory optimized compute tier, you can use up to 32 TB of storage. To provision storage, navigate to your Azure Database for PostgreSQL server, and from the Overview section select your Configuration. The Compute + Storage section is displayed. Under Storage, and Storage size (in GB) use the slider to select the amount of storage you want to be provisioned.

The amount of storage you provision defines the I/O capacity available to your Azure Database for PostgreSQL server. You can monitor your I/O consumption in the Azure portal or by using Azure CLI commands. The relevant metrics to monitor are storage limit, storage percentage, storage used, and IO percent.
https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-monitoring
 Note

You can increase the amount of storage after you have created your Azure Database for PostgreSQL server, but you cannot reduce the amount of storage.

Tablespaces - With an on-premises implementation of PostgreSQL you can create tablespaces which are linked to the main storage area called PGDATA using the pg_tblspc subdirectory. Azure Database for PostgreSQL doesn't support tablespaces: all tables are created in the main storage area.

System catalogs - PostgreSQL contains many system tables and views that store information about database objects. For example, pg_database returns all databases on a server and pg_class stores statistics about tables.

 Note

Azure Database for PostgreSQL allows access to some, but not all system catalogs.

Extensions - PostgreSQL supports a range of extensions that extend the core functionality of the database engine. These extensions are made available on a repository called the PostgreSQL Extensions Network (PGXN).

To use a PostgreSQL extension, it must be installed in your database. To install an extension, run the CREATE EXTENSION command from the psql tool to load the extension into your database. For example:

SQL

Copy
SELECT create_extension('postgis');
To find out which extensions support Azure Database for PostgreSQL, run the following query:

SQL

Copy
SELECT * FROM pg_available_extensions;
All Azure Database for PostgreSQL servers include the pg_stat_statements extension. This extension is already installed to provide functionality for tracking execution statistics of SQL statements. The server parameter pg_stat_statements.track defines what statements are counted by the extension. The options are:
https://www.postgresql.org/docs/current/pgstatstatements.html

Top - tracks all statements issued directly by clients (default).
None - no statements are tracked.
All - tracks all statements including nested statements, and statements invoked by functions.
 Note

There is performance overhead on the server to log each SQL statement. If you are not actively using pg_stat_statements, set this parameter to none. Also note that some third-party monitoring services might rely on pg_stat_statements.

Query optimizer - PostgreSQL uses a cost-based query optimization method. The parser checks the query syntax and separates the query into different parts. The parser creates a parse tree and passes the query to the rewriter, which applies rules to the query. The planner figures out the best way to execute the query before the query is executed.

Backend processes - PostgreSQL process- per-transaction model. When a new user connects, PostgreSQL authenticates the user and creates a backend server process to handle the connection. The client only interacts with the server process when submitting queries and receiving queries result.

Understand PostgreSQL shared memory
Completed
100 XP
3 minutes
PostgreSQL uses memory that can be classified as:

Local memory - allocated to each process
Shared memory - used by all processes
Local memory
Each process in PostgreSQL requires memory for query processing. The following server parameters allow you to define memory usage:

work_mem defines memory required for sorting tuples for ORDER BY and DISTINCT operations. This parameter determines the amount of memory available for internal sort operations and hash tables. If you have large amount of available memory and your workload has queries with complex sorting, increasing this parameter value could improve performance by allowing larger scans in-memory before spilling to disk.

However, one complex query could have many sort and hash operations running concurrently. Each operation uses as much memory as this value allows before it starts writing to disk based temporary files. On a busy system, therefore, total memory usage is many times that of an individual work_mem parameter.

To tune this value, use Total RAM * 0.25 / max_connections as initial value.

maintenance_work_mem is memory required by vacuum and reindex. This parameter determines the amount of memory available for internal sort operations and hash tables. The default value is 64 KB but increasing this value improves performance for vacuuming.

autovacuum_work_mem sets the maximum memory to be used by each autovacuum process.

temp_buffers defines memory for storing temporary tables. This parameter sets the maximum number of temporary buffers used by each database session.

effective_cache_size defines the amount of available memory for disk caching by the operating system and within the database. The PostgreSQL query planner determines whether this memory is fixed in RAM. Index scans are most likely to be used against higher values; otherwise, sequential scans are used if the value is low.

Set effective_cache_size to 50% of the machine's total RAM.

Shared memory
Shared memory is allocated at startup. Shared memory is used for:

shared_buffers defines the shared memory buffers used by the server. PostgreSQL loads pages of tables and indexes from persistent storage to a shared buffer pool, and then works on them in memory. This shared buffer pool is the major component of the shared memory used by the server. The default value is 128 MB (depending on the compute tier). If you decide to allocate more memory, you need to restart the server.

wal_buffers defines the number of disk page buffers in shared memory for write ahead logging (WAL) before writing it to persistent storage.

In summary, the important server parameters relating to memory that you could want tune are:

shared_buffers
work_mem
effective_cache_size

Connection states
A connection could be in one of four states:

active - active connections, which are currently running queries.
idle - open connections that aren't in use.
idle in transaction - a connection waiting, not doing any work. Use pg_stat_activity to understand what a connection is doing, and how long it's at this state.
idle in transaction (aborted) - connections that were previously idle in transaction but are now aborted.
The process-based connection model makes it expensive to maintain many idle connections.

Maximum connections
PostgreSQL limits the maximum number of concurrent connections to the server at any one time using a server parameter called max_connections. In Azure Database for PostgreSQL, the default depends on your compute tier. The allowed value is between 25 and 5000.

An on-premises implementation of PostgreSQL reserves some connections for the super user to maintain the integrity of the database. This reservation would typically be 15% of the max_connections value.

Azure Database for PostgreSQL is a managed solution and automatically reserves three connections to monitor a flexible server.

Connection pooling
Client applications that frequently open and close connections can experience connection latency, resulting in lower transactions per second, and overall higher application latency.

Azure Database for PostgreSQL recommends connection pooling instead of frequently opening and closing connections. Connection pooling reuses existing connections, rather than closing and recreating connections. This process reduces connection latency and allows higher database transactions per second for databases on the server.

Connection pooling establishes a fixed set of connections when the server is started, and these connections are then maintained. Connection pooling also helps reduce the memory fragmentation caused by new connections constantly being created on the server.

PGBouncer is a connection pooling solution that is built into Azure Database for PostgreSQL.

